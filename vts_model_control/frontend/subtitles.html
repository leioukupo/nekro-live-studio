<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时字幕</title>
    <style>
        body {
            background-color: transparent; /* OBS 透明背景 */
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-end; /* 置于底部 */
            height: 100vh;
            overflow: hidden; /* 防止滚动条 */
        }
        #subtitle-container {
            background-color: rgba(0, 0, 0, 0.75); /* 半透明黑色背景 */
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 28px; /* 根据需要调整 */
            text-align: center;
            max-width: 80%;
            min-width: 300px; /* 最小宽度 */
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            opacity: 0; /* 初始隐藏 */
            transition: opacity 0.5s ease-in-out;
            margin-bottom: 5vh; /* 距离底部5%视窗高度 */
            box-sizing: border-box;
        }
        #subtitle-text {
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div id="subtitle-container">
        <p id="subtitle-text"></p>
    </div>

    <script>
        const subtitleContainer = document.getElementById('subtitle-container');
        const subtitleTextElement = document.getElementById('subtitle-text');
        const defaultCharsPerSecond = 4; // 如果未提供语速，则默认每秒字符数
        let currentDisplayTimeout = null; // 用于控制字幕消失的计时器

        function connectWebSocket() {
            // 假设FastAPI服务与此HTML页面在同一主机和端口上，或者调整端口号
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.hostname}:${window.location.port || (wsProtocol === 'wss:' ? 443 : 80)}/ws/subtitles`;
            // 如果您的FastAPI运行在特定端口（例如8000），请明确指定：
            // const wsUrl = `${wsProtocol}//${window.location.hostname}:8000/ws/subtitles`; 
            // 在开发中，由于静态文件服务和API可能在不同端口，需要确保端口正确
            // 例如，若FastAPI在8000，此页面通过其他方式访问（如直接打开文件），则需写明 :8000
            // 为了简单起见，这里假设开发时Uvicorn在8000端口，并且你通过 http://localhost:8000/subtitles-display 访问此页面
            // 若直接打开文件 file:///... 则 window.location.port 为空, hostname 可能不准确
            // *重要*: 对于生产或OBS，请确保这里的 WebSocket URL 指向正确的 FastAPI 服务器地址和端口。
            // 对于本地测试，如果 FastAPI server.py 运行在 8000 端口，应使用: 
            // const ws = new WebSocket(`ws://localhost:8000/ws/subtitles`);
            // 为了更通用，我们尝试使用 window.location.hostname, 但端口可能需要硬编码或配置
            let explicitPort = 8080; // FastAPI/Uvicorn 默认端口，如果您的不同，请修改
            const finalWsUrl = `${wsProtocol}//${window.location.hostname}:${explicitPort}/ws/subtitles`;

            console.log(`尝试连接 WebSocket: ${finalWsUrl}`);
            const ws = new WebSocket(finalWsUrl);

            ws.onopen = () => {
                console.log("已连接到字幕 WebSocket 服务。");
                subtitleTextElement.textContent = "字幕服务已连接";
                subtitleContainer.style.opacity = 1;
                setTimeout(() => {
                    if (subtitleTextElement.textContent === "字幕服务已连接") {
                        subtitleContainer.style.opacity = 0;
                        subtitleTextElement.textContent = "";
                    }
                }, 3000);
            };

            ws.onmessage = async (event) => {
                if (currentDisplayTimeout) {
                    clearTimeout(currentDisplayTimeout);
                    currentDisplayTimeout = null;
                }
                try {
                    const message = JSON.parse(event.data);
                    console.log("收到消息:", message);

                    if (message.type === "subtitles" && message.payload) {
                        const { texts, speeds, actionStartTime } = message.payload;
                        
                        if (actionStartTime && actionStartTime > 0) {
                            console.log(`动作延时: ${actionStartTime}s`);
                            await new Promise(resolve => setTimeout(resolve, actionStartTime * 1000));
                        }

                        subtitleContainer.style.opacity = 1; // 显示容器

                        for (let i = 0; i < texts.length; i++) {
                            const textSegment = texts[i];
                            subtitleTextElement.textContent = ""; // 为当前片段清空字幕区
                            
                            let charSpeed = defaultCharsPerSecond;
                            if (speeds) {
                                if (speeds.length > i && speeds[i] > 0) {
                                    charSpeed = speeds[i];
                                } else if (speeds.length === 1 && speeds[0] > 0) {
                                    // 如果speeds列表只有一个元素，则将其用于所有文本片段
                                    charSpeed = speeds[0];
                                }
                            }
                            // 确保charSpeed是一个有效值，防止除以0或负数
                            if (charSpeed <= 0) charSpeed = defaultCharsPerSecond; 

                            const charDelayMs = (1 / charSpeed) * 1000;
                            console.log(`显示片段: "${textSegment}" (逐字模式), 速度: ${charSpeed} chars/s, 字间延迟: ${charDelayMs}ms`);

                            // 修改循环以使用索引
                            for (let charIndex = 0; charIndex < textSegment.length; charIndex++) {
                                const char = textSegment[charIndex];
                                subtitleTextElement.textContent += char;
                                // 只有在不是最后一个字符时才应用延迟
                                if (charIndex < textSegment.length - 1) {
                                    await new Promise(resolve => setTimeout(resolve, charDelayMs));
                                }
                            }
                        }
                        
                        // 所有片段显示完毕后，设置延时隐藏
                        currentDisplayTimeout = setTimeout(() => {
                            console.log("开始隐藏字幕...");
                            subtitleContainer.style.opacity = 0; // 触发CSS过渡效果 (0.5s)
                            // 在CSS过渡结束后清除文本内容
                            setTimeout(() => {
                                subtitleTextElement.textContent = ""; 
                                console.log("字幕文本已清空，容器已（或正在）完全透明");
                            }, 500); // 匹配CSS中opacity的transition duration (0.5s = 500ms)
                        }, 3000); // 3秒后无新消息则隐藏
                    }
                } catch (error) {
                    console.error("处理消息或显示字幕时出错:", error);
                    subtitleTextElement.textContent = "字幕显示错误"; // 显示错误信息
                    subtitleContainer.style.opacity = 1; // 确保容器可见

                    // 如果之前有隐藏计时器，清除它，避免重复或冲突的隐藏操作
                    if (currentDisplayTimeout) {
                        clearTimeout(currentDisplayTimeout);
                    }

                    currentDisplayTimeout = setTimeout(() => {
                        console.log("开始隐藏错误提示字幕...");
                        subtitleContainer.style.opacity = 0; // 触发CSS过渡效果 (0.5s)
                        setTimeout(() => {
                            subtitleTextElement.textContent = ""; 
                            console.log("错误提示字幕文本已清空，容器已（或正在）完全透明");
                        }, 500); // 匹配CSS中opacity的transition duration
                    }, 3000); // 错误信息也显示3秒后隐藏
                }
            };

            ws.onclose = (event) => {
                console.log("WebSocket 连接已关闭。代码:", event.code, "原因:", event.reason);
                subtitleTextElement.textContent = "字幕服务连接断开。尝试重连...";
                subtitleContainer.style.opacity = 1;
                // 尝试在5秒后重连
                setTimeout(connectWebSocket, 5000);
            };

            ws.onerror = (error) => {
                console.error("WebSocket 错误:", error);
                subtitleTextElement.textContent = "字幕服务连接错误。";
                subtitleContainer.style.opacity = 1;
                // 也可以在这里触发重连
            };
        }

        // 初始连接
        connectWebSocket();
    </script>
</body>
</html> 